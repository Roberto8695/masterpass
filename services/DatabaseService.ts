import * as SQLite from 'expo-sqlite';
import * as FileSystem from 'expo-file-system';
import * as Sharing from 'expo-sharing';
import { encryptionService } from './EncryptionService';

// Interfaces para los tipos de datos
export interface DatabasePasswordEntry {
  id: string;
  siteName: string;
  siteUrl?: string;
  username?: string;
  email?: string;
  password: string;
  category: string;
  tags: string;
  notes?: string;
  favicon?: string;
  options: string; // JSON encriptado de PasswordOptions
  createdAt: number;
  lastModified: number;
  lastUsed?: number;
  isDeleted: boolean;
}

export interface PasswordOptions {
  length: number;
  includeNumbers: boolean;
  includeSymbols: boolean;
  excludeSimilar?: boolean;
  excludeAmbiguous?: boolean;
  startWithLetter?: boolean;
  noRepeatingChars?: boolean;
}

export class DatabaseService {
  private db: SQLite.SQLiteDatabase | null = null;
  private isInitialized = false;
  private isInitializing = false;

  // Singleton pattern
  private static instance: DatabaseService;
  
  public static getInstance(): DatabaseService {
    if (!DatabaseService.instance) {
      DatabaseService.instance = new DatabaseService();
    }
    return DatabaseService.instance;
  }

  private constructor() {}

  /**
   * Inicializar la base de datos y crear las tablas
   */
  async initialize(): Promise<void> {
    // Evitar m√∫ltiples inicializaciones
    if (this.isInitialized) {
      console.log('üìã Base de datos ya inicializada');
      return;
    }
    
    if (this.isInitializing) {
      console.log('‚è≥ Inicializaci√≥n ya en progreso...');
      return;
    }

    this.isInitializing = true;

    try {
      console.log('üîß Inicializando base de datos SQLite...');
      
      // Primero inicializar el servicio de encriptaci√≥n
      console.log('üîê Inicializando servicio de encriptaci√≥n...');
      try {
        await encryptionService.initialize();
        console.log('‚úÖ Servicio de encriptaci√≥n inicializado correctamente');
      } catch (encryptionError) {
        console.error('‚ùå Error espec√≠fico en encriptaci√≥n:', encryptionError);
        throw encryptionError;
      }
      
      // Abrir la base de datos encriptada
      this.db = await SQLite.openDatabaseAsync('masterpass_vault.db');
      
      // Crear tabla de contrase√±as si no existe
      await this.createTables();
      
      this.isInitialized = true;
      console.log('‚úÖ Base de datos SQLite inicializada correctamente');
    } catch (error) {
      console.error('‚ùå Error inicializando base de datos:', error);
      throw new Error('No se pudo inicializar la base de datos');
    } finally {
      this.isInitializing = false;
    }
  }

  /**
   * Crear las tablas necesarias
   */
  private async createTables(): Promise<void> {
    if (!this.db) throw new Error('Base de datos no inicializada');

    const createPasswordsTable = `
      CREATE TABLE IF NOT EXISTS passwords (
        id TEXT PRIMARY KEY NOT NULL,
        siteName TEXT NOT NULL,
        siteUrl TEXT,
        username TEXT,
        email TEXT,
        password TEXT NOT NULL,
        category TEXT DEFAULT 'General',
        tags TEXT DEFAULT '',
        notes TEXT,
        favicon TEXT,
        options TEXT NOT NULL,
        createdAt INTEGER NOT NULL,
        lastModified INTEGER NOT NULL,
        lastUsed INTEGER,
        isDeleted INTEGER DEFAULT 0
      );
    `;

    const createIndexes = `
      CREATE INDEX IF NOT EXISTS idx_passwords_siteName ON passwords(siteName);
      CREATE INDEX IF NOT EXISTS idx_passwords_category ON passwords(category);
      CREATE INDEX IF NOT EXISTS idx_passwords_createdAt ON passwords(createdAt);
      CREATE INDEX IF NOT EXISTS idx_passwords_isDeleted ON passwords(isDeleted);
    `;

    try {
      await this.db.execAsync(createPasswordsTable);
      await this.db.execAsync(createIndexes);
      console.log('‚úÖ Tablas creadas correctamente');
    } catch (error) {
      console.error('‚ùå Error creando tablas:', error);
      throw error;
    }
  }

  /**
   * Verificar si la base de datos est√° lista
   */
  isReady(): boolean {
    return this.isInitialized && this.db !== null && encryptionService.isReady();
  }

  /**
   * Guardar una nueva contrase√±a encriptada
   */
  async savePassword(
    password: string,
    options: PasswordOptions,
    siteName: string = 'Contrase√±a General',
    additionalData?: {
      siteUrl?: string;
      username?: string;
      email?: string;
      category?: string;
      tags?: string[];
      notes?: string;
    }
  ): Promise<string> {
    if (!this.isReady()) {
      throw new Error('Base de datos no inicializada');
    }

    try {
      const id = `pwd_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const now = Date.now();

      // Encriptar la contrase√±a y las opciones
      const encryptedPassword = await encryptionService.encrypt(password);
      const encryptedOptions = await encryptionService.encrypt(JSON.stringify(options));

      // Convertir datos encriptados a string para almacenamiento
      const encryptedPasswordStr = JSON.stringify(encryptedPassword);
      const encryptedOptionsStr = JSON.stringify(encryptedOptions);

      const insertQuery = `
        INSERT INTO passwords (
          id, siteName, siteUrl, username, email, password, 
          category, tags, notes, favicon, options, 
          createdAt, lastModified, isDeleted
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 0)
      `;

      const params = [
        id,
        siteName,
        additionalData?.siteUrl || null,
        additionalData?.username || null,
        additionalData?.email || null,
        encryptedPasswordStr,
        additionalData?.category || 'General',
        JSON.stringify(additionalData?.tags || []),
        additionalData?.notes || null,
        null, // favicon - lo implementaremos m√°s tarde
        encryptedOptionsStr,
        now,
        now
      ];

      await this.db!.runAsync(insertQuery, params);
      
      console.log(`‚úÖ Contrase√±a guardada en BD encriptada: ${id}`);
      return id;
    } catch (error) {
      console.error('‚ùå Error guardando contrase√±a en BD:', error);
      throw new Error('No se pudo guardar la contrase√±a en la base de datos');
    }
  }

  /**
   * Actualizar una contrase√±a existente
   */
  async updatePassword(
    id: string,
    password?: string,
    options?: PasswordOptions,
    siteName?: string,
    additionalData?: {
      siteUrl?: string;
      username?: string;
      email?: string;
      category?: string;
      tags?: string[];
      notes?: string;
    }
  ): Promise<void> {
    if (!this.isReady()) {
      throw new Error('Base de datos no inicializada');
    }

    try {
      const now = Date.now();

      // Construir la consulta y par√°metros din√°micamente
      const updateFields: string[] = [];
      const params: any[] = [];

      // Solo actualizar campos que se proporcionen
      if (password !== undefined) {
        const encryptedPassword = await encryptionService.encrypt(password);
        const encryptedPasswordStr = JSON.stringify(encryptedPassword);
        updateFields.push('password = ?');
        params.push(encryptedPasswordStr);
      }

      if (options !== undefined) {
        const encryptedOptions = await encryptionService.encrypt(JSON.stringify(options));
        const encryptedOptionsStr = JSON.stringify(encryptedOptions);
        updateFields.push('options = ?');
        params.push(encryptedOptionsStr);
      }

      if (siteName !== undefined) {
        updateFields.push('siteName = ?');
        params.push(siteName);
      }

      if (additionalData?.siteUrl !== undefined) {
        updateFields.push('siteUrl = ?');
        params.push(additionalData.siteUrl || null);
      }

      if (additionalData?.username !== undefined) {
        updateFields.push('username = ?');
        params.push(additionalData.username || null);
      }

      if (additionalData?.email !== undefined) {
        updateFields.push('email = ?');
        params.push(additionalData.email || null);
      }

      if (additionalData?.category !== undefined) {
        updateFields.push('category = ?');
        params.push(additionalData.category);
      }

      if (additionalData?.tags !== undefined) {
        updateFields.push('tags = ?');
        params.push(JSON.stringify(additionalData.tags));
      }

      if (additionalData?.notes !== undefined) {
        updateFields.push('notes = ?');
        params.push(additionalData.notes || null);
      }

      // Siempre actualizar lastModified
      updateFields.push('lastModified = ?');
      params.push(now);

      // Agregar ID al final para la cl√°usula WHERE
      params.push(id);

      if (updateFields.length === 1) { // Solo lastModified
        throw new Error('No se proporcionaron campos para actualizar');
      }

      const updateQuery = `
        UPDATE passwords 
        SET ${updateFields.join(', ')}
        WHERE id = ? AND isDeleted = 0
      `;

      const result = await this.db!.runAsync(updateQuery, params);
      
      if (result.changes === 0) {
        throw new Error('No se encontr√≥ la contrase√±a para actualizar');
      }
      
      console.log(`‚úÖ Contrase√±a actualizada en BD: ${id}`);
    } catch (error) {
      console.error('‚ùå Error actualizando contrase√±a en BD:', error);
      throw new Error('No se pudo actualizar la contrase√±a en la base de datos');
    }
  }

  /**
   * Cargar todas las contrase√±as desencriptadas
   */
  async loadPasswords(): Promise<Array<{
    id: string;
    siteName: string;
    siteUrl?: string;
    username?: string;
    email?: string;
    password: string;
    category: string;
    tags: string[];
    notes?: string;
    options: PasswordOptions;
    createdAt: Date;
    lastModified: Date;
    lastUsed?: Date;
  }>> {
    if (!this.isReady()) {
      throw new Error('Base de datos no inicializada');
    }

    try {
      const query = `
        SELECT * FROM passwords 
        WHERE isDeleted = 0 
        ORDER BY createdAt DESC
      `;

      const result = await this.db!.getAllAsync(query) as DatabasePasswordEntry[];
      
      // Desencriptar y formatear los resultados
      const decryptedPasswords = await Promise.all(
        result.map(async (row) => {
          try {
            // Convertir strings de BD de vuelta a EncryptedData
            const encryptedPasswordData = JSON.parse(row.password);
            const encryptedOptionsData = JSON.parse(row.options);
            
            const decryptedPassword = await encryptionService.decrypt(encryptedPasswordData);
            const decryptedOptions = JSON.parse(
              await encryptionService.decrypt(encryptedOptionsData)
            ) as PasswordOptions;

            return {
              id: row.id,
              siteName: row.siteName,
              siteUrl: row.siteUrl || undefined,
              username: row.username || undefined,
              email: row.email || undefined,
              password: decryptedPassword,
              category: row.category,
              tags: JSON.parse(row.tags || '[]'),
              notes: row.notes || undefined,
              options: decryptedOptions,
              createdAt: new Date(row.createdAt),
              lastModified: new Date(row.lastModified),
              lastUsed: row.lastUsed ? new Date(row.lastUsed) : undefined,
            };
          } catch (decryptError) {
            console.error(`‚ùå Error desencriptando contrase√±a ${row.id}:`, decryptError);
            // Retornar entrada con error para debugging
            return null;
          }
        })
      );

      // Filtrar entradas nulas (errores de desencriptaci√≥n)
      const validPasswords = decryptedPasswords.filter(p => p !== null);
      
      console.log(`‚úÖ Cargadas ${validPasswords.length} contrase√±as de la BD`);
      return validPasswords as any;
    } catch (error) {
      console.error('‚ùå Error cargando contrase√±as de BD:', error);
      throw new Error('No se pudieron cargar las contrase√±as de la base de datos');
    }
  }

  /**
   * Eliminar una contrase√±a (soft delete)
   */
  async deletePassword(id: string): Promise<void> {
    if (!this.isReady()) {
      throw new Error('Base de datos no inicializada');
    }

    try {
      const updateQuery = `
        UPDATE passwords 
        SET isDeleted = 1, lastModified = ? 
        WHERE id = ?
      `;

      await this.db!.runAsync(updateQuery, [Date.now(), id]);
      console.log(`‚úÖ Contrase√±a marcada como eliminada: ${id}`);
    } catch (error) {
      console.error('‚ùå Error eliminando contrase√±a de BD:', error);
      throw new Error('No se pudo eliminar la contrase√±a de la base de datos');
    }
  }

  /**
   * Actualizar √∫ltima vez usada
   */
  async updateLastUsed(id: string): Promise<void> {
    if (!this.isReady()) {
      throw new Error('Base de datos no inicializada');
    }

    try {
      const updateQuery = `
        UPDATE passwords 
        SET lastUsed = ?, lastModified = ? 
        WHERE id = ?
      `;

      const now = Date.now();
      await this.db!.runAsync(updateQuery, [now, now, id]);
    } catch (error) {
      console.error('‚ùå Error actualizando √∫ltima vez usado:', error);
    }
  }

  /**
   * Buscar contrase√±as por sitio
   */
  async searchBySite(siteName: string): Promise<Array<any>> {
    if (!this.isReady()) {
      throw new Error('Base de datos no inicializada');
    }

    try {
      const query = `
        SELECT * FROM passwords 
        WHERE siteName LIKE ? AND isDeleted = 0 
        ORDER BY lastUsed DESC, createdAt DESC
      `;

      const result = await this.db!.getAllAsync(query, [`%${siteName}%`]) as DatabasePasswordEntry[];
      
      // Desencriptar resultados
      const decryptedResults = await Promise.all(
        result.map(async (row) => {
          // Convertir strings de BD de vuelta a EncryptedData
          const encryptedPasswordData = JSON.parse(row.password);
          const encryptedOptionsData = JSON.parse(row.options);
          
          const decryptedPassword = await encryptionService.decrypt(encryptedPasswordData);
          const decryptedOptions = JSON.parse(
            await encryptionService.decrypt(encryptedOptionsData)
          );

          return {
            id: row.id,
            siteName: row.siteName,
            password: decryptedPassword,
            options: decryptedOptions,
            createdAt: new Date(row.createdAt),
            lastUsed: row.lastUsed ? new Date(row.lastUsed) : undefined,
          };
        })
      );

      return decryptedResults;
    } catch (error) {
      console.error('‚ùå Error buscando por sitio:', error);
      throw error;
    }
  }

  /**
   * Obtener estad√≠sticas de la base de datos
   */
  async getStatistics(): Promise<{
    totalPasswords: number;
    categoryCounts: Record<string, number>;
    weakPasswords: number;
    reusedPasswords: number;
    oldestPassword?: Date;
    newestPassword?: Date;
  }> {
    if (!this.isReady()) {
      throw new Error('Base de datos no inicializada');
    }

    try {
      // Contar total de contrase√±as
      const totalQuery = `SELECT COUNT(*) as count FROM passwords WHERE isDeleted = 0`;
      const totalResult = await this.db!.getFirstAsync(totalQuery) as { count: number };

      // Contar por categor√≠as
      const categoryQuery = `
        SELECT category, COUNT(*) as count 
        FROM passwords 
        WHERE isDeleted = 0 
        GROUP BY category
      `;
      const categoryResult = await this.db!.getAllAsync(categoryQuery) as Array<{ category: string; count: number }>;

      // Fechas extremas
      const datesQuery = `
        SELECT MIN(createdAt) as oldest, MAX(createdAt) as newest 
        FROM passwords 
        WHERE isDeleted = 0
      `;
      const datesResult = await this.db!.getFirstAsync(datesQuery) as { oldest: number; newest: number };

      const categoryCounts: Record<string, number> = {};
      categoryResult.forEach(cat => {
        categoryCounts[cat.category] = cat.count;
      });

      return {
        totalPasswords: totalResult.count,
        categoryCounts,
        weakPasswords: 0, // Implementaremos an√°lisis de debilidad
        reusedPasswords: 0, // Implementaremos an√°lisis de reutilizaci√≥n
        oldestPassword: datesResult.oldest ? new Date(datesResult.oldest) : undefined,
        newestPassword: datesResult.newest ? new Date(datesResult.newest) : undefined,
      };
    } catch (error) {
      console.error('‚ùå Error obteniendo estad√≠sticas:', error);
      throw error;
    }
  }

  /**
   * Exportar todas las contrase√±as a un archivo CSV
   */
  async exportToCSV(): Promise<{ success: boolean; filePath?: string; fileName?: string; error?: string }> {
    if (!this.isReady()) {
      return { success: false, error: 'Base de datos no inicializada' };
    }

    try {
      const passwords = await this.loadPasswords();
      
      if (passwords.length === 0) {
        return { success: false, error: 'No hay contrase√±as para exportar' };
      }

      // Crear encabezados CSV
      const headers = [
        'Sitio',
        'URL',
        'Usuario',
        'Email', 
        'Contrase√±a',
        'Categor√≠a',
        'Etiquetas',
        'Notas',
        'Fecha Creaci√≥n',
        '√öltima Modificaci√≥n',
        '√öltimo Uso'
      ];

      // Funci√≥n para escapar campos CSV
      const escapeCSV = (field: string): string => {
        if (!field) return '';
        // Escapar comillas dobles duplic√°ndolas
        const escaped = field.replace(/"/g, '""');
        // Envolver en comillas si contiene comas, saltos de l√≠nea o comillas
        if (escaped.includes(',') || escaped.includes('\n') || escaped.includes('"')) {
          return `"${escaped}"`;
        }
        return escaped;
      };

      // Crear filas CSV
      const rows = passwords.map(p => [
        escapeCSV(p.siteName),
        escapeCSV(p.siteUrl || ''),
        escapeCSV(p.username || ''),
        escapeCSV(p.email || ''),
        escapeCSV(p.password), // Contrase√±a encriptada
        escapeCSV(p.category),
        escapeCSV(Array.isArray(p.tags) ? p.tags.join('; ') : ''),
        escapeCSV(p.notes || ''),
        escapeCSV(p.createdAt.toISOString()),
        escapeCSV(p.lastModified.toISOString()),
        escapeCSV(p.lastUsed?.toISOString() || '')
      ]);

      // Combinar encabezados y filas
      const csvContent = [
        headers.join(','),
        ...rows.map(row => row.join(','))
      ].join('\n');

      // Agregar BOM para compatibilidad con Excel
      const csvWithBOM = '\ufeff' + csvContent;
      
      // Generar nombre de archivo √∫nico con timestamp
      const now = new Date();
      const timestamp = now.toISOString()
        .replace(/[:.]/g, '-')
        .substring(0, 19); // YYYY-MM-DDTHH-MM-SS
      const fileName = `masterpass-backup-${timestamp}.csv`;
      
      // Definir ruta del archivo
      const fileUri = `${FileSystem.documentDirectory}${fileName}`;
      
      // Escribir archivo CSV
      await FileSystem.writeAsStringAsync(fileUri, csvWithBOM, {
        encoding: FileSystem.EncodingType.UTF8,
      });

      console.log('‚úÖ Archivo CSV creado:', fileUri);
      console.log('üìÅ Ubicaci√≥n:', FileSystem.documentDirectory);
      console.log('üìÑ Nombre del archivo:', fileName);
      console.log('üìä Total de contrase√±as exportadas:', passwords.length);
      
      // Verificar que el archivo se cre√≥ correctamente
      const fileInfo = await FileSystem.getInfoAsync(fileUri);
      if (!fileInfo.exists) {
        return { success: false, error: 'No se pudo crear el archivo CSV' };
      }

      // Compartir archivo si la plataforma lo soporta
      try {
        if (await Sharing.isAvailableAsync()) {
          await Sharing.shareAsync(fileUri, {
            mimeType: 'text/csv',
            dialogTitle: `Exportar CSV de MasterPass (${passwords.length} cuentas)`,
            UTI: 'public.comma-separated-values-text'
          });
        }
      } catch (shareError) {
        console.warn('‚ö†Ô∏è No se pudo compartir el archivo CSV autom√°ticamente:', shareError);
      }

      return { 
        success: true, 
        filePath: fileUri,
        fileName: fileName,
        error: undefined
      };

    } catch (error) {
      console.error('‚ùå Error exportando a CSV:', error);
      return { 
        success: false, 
        error: `Error durante la exportaci√≥n CSV: ${error}` 
      };
    }
  }

  /**
   * Exportar todas las contrase√±as a un archivo JSON
   */
  async exportToFile(): Promise<{ success: boolean; filePath?: string; fileName?: string; error?: string }> {
    if (!this.isReady()) {
      return { success: false, error: 'Base de datos no inicializada' };
    }

    try {
      const passwords = await this.loadPasswords();
      
      if (passwords.length === 0) {
        return { success: false, error: 'No hay contrase√±as para exportar' };
      }

      // Crear datos de exportaci√≥n
      const exportData = {
        appName: 'MasterPass',
        version: '1.0.0',
        exportDate: new Date().toISOString(),
        totalPasswords: passwords.length,
        encrypted: true,
        format: 'MasterPass JSON Export',
        note: 'Este archivo contiene tus contrase√±as encriptadas. Mant√©nlo seguro.',
        passwords: passwords.map(p => ({
          id: p.id,
          siteName: p.siteName,
          siteUrl: p.siteUrl || '',
          username: p.username || '',
          email: p.email || '',
          password: p.password, // Ya est√° encriptado
          category: p.category,
          tags: Array.isArray(p.tags) ? p.tags : [],
          notes: p.notes || '',
          options: p.options,
          createdAt: p.createdAt.toISOString(),
          lastModified: p.lastModified.toISOString(),
          lastUsed: p.lastUsed?.toISOString()
        }))
      };

      // Crear contenido JSON formateado
      const jsonContent = JSON.stringify(exportData, null, 2);
      
      // Generar nombre de archivo √∫nico con timestamp
      const now = new Date();
      const timestamp = now.toISOString()
        .replace(/[:.]/g, '-')
        .substring(0, 19); // YYYY-MM-DDTHH-MM-SS
      const fileName = `masterpass-backup-${timestamp}.json`;
      
      // Definir ruta del archivo en la carpeta de documentos del usuario
      const fileUri = `${FileSystem.documentDirectory}${fileName}`;
      
      // Escribir archivo
      await FileSystem.writeAsStringAsync(fileUri, jsonContent, {
        encoding: FileSystem.EncodingType.UTF8,
      });

      console.log('‚úÖ Archivo de exportaci√≥n creado:', fileUri);
      console.log('üìÅ Ubicaci√≥n:', FileSystem.documentDirectory);
      console.log('üìÑ Nombre del archivo:', fileName);
      console.log('üìä Total de contrase√±as exportadas:', passwords.length);
      
      // Verificar que el archivo se cre√≥ correctamente
      const fileInfo = await FileSystem.getInfoAsync(fileUri);
      if (!fileInfo.exists) {
        return { success: false, error: 'No se pudo crear el archivo de exportaci√≥n' };
      }

      // Compartir archivo si la plataforma lo soporta
      try {
        if (await Sharing.isAvailableAsync()) {
          await Sharing.shareAsync(fileUri, {
            mimeType: 'application/json',
            dialogTitle: `Exportar respaldo de MasterPass (${passwords.length} cuentas)`,
            UTI: 'public.json'
          });
        }
      } catch (shareError) {
        console.warn('‚ö†Ô∏è No se pudo compartir el archivo autom√°ticamente:', shareError);
        // No es un error cr√≠tico, el archivo se cre√≥ correctamente
      }

      return { 
        success: true, 
        filePath: fileUri,
        fileName: fileName,
        error: undefined
      };

    } catch (error) {
      console.error('‚ùå Error exportando a archivo:', error);
      return { 
        success: false, 
        error: `Error durante la exportaci√≥n: ${error}` 
      };
    }
  }

  /**
   * Exportar todas las contrase√±as (para backup) - Funci√≥n legacy
   */
  async exportAll(): Promise<string> {
    if (!this.isReady()) {
      throw new Error('Base de datos no inicializada');
    }

    try {
      const passwords = await this.loadPasswords();
      const exportData = {
        version: '1.0',
        exportDate: new Date().toISOString(),
        passwords: passwords.map(p => ({
          siteName: p.siteName,
          siteUrl: p.siteUrl,
          username: p.username,
          email: p.email,
          password: p.password,
          category: p.category,
          tags: p.tags,
          notes: p.notes,
          options: p.options,
          createdAt: p.createdAt.toISOString(),
        }))
      };

      return JSON.stringify(exportData, null, 2);
    } catch (error) {
      console.error('‚ùå Error exportando datos:', error);
      throw error;
    }
  }

  /**
   * Limpiar toda la base de datos
   */
  async clearAll(): Promise<void> {
    if (!this.isReady()) {
      throw new Error('Base de datos no inicializada');
    }

    try {
      await this.db!.runAsync('DELETE FROM passwords');
      console.log('‚úÖ Base de datos limpiada completamente');
    } catch (error) {
      console.error('‚ùå Error limpiando base de datos:', error);
      throw error;
    }
  }

  /**
   * Cerrar la conexi√≥n a la base de datos
   */
  async close(): Promise<void> {
    if (this.db) {
      await this.db.closeAsync();
      this.db = null;
      this.isInitialized = false;
      console.log('‚úÖ Conexi√≥n a base de datos cerrada');
    }
  }
}

// Exportar instancia singleton
export const databaseService = DatabaseService.getInstance();
